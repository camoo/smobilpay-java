/*
 * Smobilpay S3P API STANDARD Smobilpay Third Party STANDARD API FOR PAYMENT COLLECTIONS OpenAPI
 * spec version: 3.0.0 NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git Do not edit the class manually.
 */

package org.maviance.s3pjavaclient.api;

import com.google.gson.reflect.TypeToken;
import com.squareup.okhttp.Call;
import org.maviance.s3pjavaclient.*;
import org.maviance.s3pjavaclient.model.*;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
/**
 * This class contains the different methods to hit the different endpoints.
 * @see org.maviance.s3pjavaclient.api.BaseApi*/
public class CollectionApi extends BaseApi {

    public CollectionApi() {
        super();
    }

    public CollectionApi(ApiClient apiClient) {
        super(apiClient);
    }

    /**
     * Build call for billGet
     * @param merchant
     *            Unique merchant code (required)
     * @param serviceid
     *            Unique service Identifier (required)
     * @param serviceNumber
     *            Service number with merchant (e.g. meter number in bills from a utility provider)
     *            for which to perform the bill payment (required)
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call billGetCall(String merchant, Integer serviceid, String serviceNumber,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (merchant != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("merchant", merchant));
        if (serviceid != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("serviceid", serviceid));
        if (serviceNumber != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("serviceNumber", serviceNumber));

        return getCall(progressListener, progressRequestListener, "/bill", localVarQueryParams);
    }

    private Call billGetValidateBeforeCall(String merchant, Integer serviceid, String serviceNumber,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'xApiVersion' is set
       //not needed xApiVersion is always set
        /* if (this.xApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xApiVersion' when calling billGet(Async)");
        }*/

        // verify the required parameter 'merchant' is set
        if (merchant == null) {
            throw new ApiException("Missing the required parameter 'merchant' when calling billGet(Async)");
        }

        // verify the required parameter 'serviceid' is set
        if (serviceid == null) {
            throw new ApiException("Missing the required parameter 'serviceid' when calling billGet(Async)");
        }

        // verify the required parameter 'serviceNumber' is set
        if (serviceNumber == null) {
            throw new ApiException("Missing the required parameter 'serviceNumber' when calling billGet(Async)");
        }

        return billGetCall(merchant, serviceid, serviceNumber, progressListener, progressRequestListener);
    }

    /**
     * Get bill payment handler A request to this endpoint returns bill payment handler records for
     * a service by a service number and retrieves its details if available. Bill payments come in 2
     * flavors – which are determined by the related service’s type: 1. **SEARCHABLE_BILL** – When
     * calling the endpoint for searchable bills, the result set will contain a list of all open
     * bills for the selected service number. Each bill has its own Payment Item Identifier. 2.
     * **NON_SEARCHABLE_BILL** – When calling the endpoint for non-searchable bills, the result set
     * will always contain a single bill item with a Payment Item ID to perform the collection for
     * the provided service number.
     * @param merchant
     *            Unique merchant code (required)
     * @param serviceid
     *            Unique service Identifier (required)
     * @param serviceNumber
     *            Service number with merchant (e.g. meter number in bills from a utility provider)
     *            for which to perform the bill payment (required)
     * @return List&lt;Bill&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public List<Bill> billGet(String merchant, Integer serviceid, String serviceNumber) throws ApiException {
        ApiResponse<List<Bill>> resp = billGetWithHttpInfo(merchant, serviceid, serviceNumber);
        return resp.getData();
    }

    /**
     * Get bill payment handler A request to this endpoint returns bill payment handler records for
     * a service by a service number and retrieves its details if available. Bill payments come in 2
     * flavors – which are determined by the related service’s type: 1. **SEARCHABLE_BILL** – When
     * calling the endpoint for searchable bills, the result set will contain a list of all open
     * bills for the selected service number. Each bill has its own Payment Item Identifier. 2.
     * **NON_SEARCHABLE_BILL** – When calling the endpoint for non-searchable bills, the result set
     * will always contain a single bill item with a Payment Item ID to perform the collection for
     * the provided service number.
     * @param merchant
     *            Unique merchant code (required)
     * @param serviceid
     *            Unique service Identifier (required)
     * @param serviceNumber
     *            Service number with merchant (e.g. meter number in bills from a utility provider)
     *            for which to perform the bill payment (required)
     * @return ApiResponse&lt;List&lt;Bill&gt;&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<List<Bill>> billGetWithHttpInfo(String merchant, Integer serviceid, String serviceNumber)
            throws ApiException {
        Call call = billGetValidateBeforeCall(merchant, serviceid, serviceNumber, null, null);
        Type localVarReturnType = new TypeToken<List<Bill>>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get bill payment handler (asynchronously) A request to this endpoint returns bill payment
     * handler records for a service by a service number and retrieves its details if available.
     * Bill payments come in 2 flavors – which are determined by the related service’s type: 1.
     * **SEARCHABLE_BILL** – When calling the endpoint for searchable bills, the result set will
     * contain a list of all open bills for the selected service number. Each bill has its own
     * Payment Item Identifier. 2. **NON_SEARCHABLE_BILL** – When calling the endpoint for
     * non-searchable bills, the result set will always contain a single bill item with a Payment
     * Item ID to perform the collection for the provided service number.
     * @param merchant
     *            Unique merchant code (required)
     * @param serviceid
     *            Unique service Identifier (required)
     * @param serviceNumber
     *            Service number with merchant (e.g. meter number in bills from a utility provider)
     *            for which to perform the bill payment (required)
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call billGetAsync(String merchant, Integer serviceid, String serviceNumber,
            final ApiCallback<List<Bill>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = billGetValidateBeforeCall(merchant, serviceid, serviceNumber, progressListener,
                progressRequestListener);
        Type localVarReturnType = new TypeToken<List<Bill>>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for cashinGet
     * @param serviceid
     *            Filter cashin packages for only the selected service (optional)
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call cashInGetCall(Integer serviceid,
                              final ProgressResponseBody.ProgressListener progressListener,
                              final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (serviceid != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("serviceid", serviceid));

        return getCall(progressListener, progressRequestListener, "/cashin", localVarQueryParams);
    }

    private Call cashInGetValidateBeforeCall(Integer serviceid,
                                             final ProgressResponseBody.ProgressListener progressListener,
                                             final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'xApiVersion' is set
        //not needed xApiVersion is always set
        /* if (this.xApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xApiVersion' when calling cashIn(Async)");
        }*/


        Call call = cashInGetCall(serviceid, progressListener, progressRequestListener);
        return call;
    }

    /**
     * Retrieve available cashin packages This service provides available cashin packages to be made
     * to the system.
     * @param serviceid
     *            Filter cashin packages for only the selected service (optional)
     * @return List&lt;Cashin&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public List<Cashin> cashinGet(Integer serviceid) throws ApiException {
        ApiResponse<List<Cashin>> resp = cashinGetWithHttpInfo(serviceid);
        return resp.getData();
    }

    /**
     * Retrieve available cashin packages This service provides available cashin packages to be made
     * to the system.
     * @param serviceid
     *            Filter cashin packages for only the selected service (optional)
     * @return ApiResponse&lt;List&lt;Cashin&gt;&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<List<Cashin>> cashinGetWithHttpInfo(Integer serviceid) throws ApiException {
        Call call = cashInGetValidateBeforeCall(serviceid, null, null);
        Type localVarReturnType = new TypeToken<List<Cashin>>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Retrieve available cashin packages (asynchronously) This service provides available cashin
     * packages to be made to the system.
     * @param serviceid
     *            Filter cashin packages for only the selected service (optional)
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call cashInGetAsync(Integer serviceid, final ApiCallback<List<Cashin>> callback)
            throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call =
                cashInGetValidateBeforeCall(serviceid, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<Cashin>>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for cashoutGet
     * @param serviceid
     *            Filter cashout packages for only the selected service (optional)
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call cashoutGetCall(Integer serviceid,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (serviceid != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("serviceid", serviceid));

        return getCall(progressListener, progressRequestListener, "/cashout", localVarQueryParams);
    }

    private Call cashoutGetValidateBeforeCall(Integer serviceid,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'xApiVersion' is set
        //not needed xApiVersion is always set
        /* if (this.xApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xApiVersion' when calling cashOut(Async)");
        }*/


        Call call = cashoutGetCall(serviceid, progressListener, progressRequestListener);
        return call;
    }

    /**
     * Retrieves available cashout packages This service provides available cashout packages to be
     * made to the system.
     * @param serviceid
     *            Filter cashout packages for only the selected service (optional)
     * @return List&lt;Cashout&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public List<Cashout> cashoutGet(Integer serviceid) throws ApiException {
        ApiResponse<List<Cashout>> resp = cashoutGetWithHttpInfo(serviceid);
        return resp.getData();
    }

    /**
     * Retrieves available cashout packages This service provides available cashout packages to be
     * made to the system.
     * @param serviceid
     *            Filter cashout packages for only the selected service (optional)
     * @return ApiResponse&lt;List&lt;Cashout&gt;&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<List<Cashout>> cashoutGetWithHttpInfo(Integer serviceid) throws ApiException {
        Call call = cashoutGetValidateBeforeCall(serviceid, null, null);
        Type localVarReturnType = new TypeToken<List<Cashout>>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Retrieves available cashout packages (asynchronously) This service provides available cashout
     * packages to be made to the system.
     * @param serviceid
     *            Filter cashout packages for only the selected service (optional)
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call cashoutGetAsync(Integer serviceid, final ApiCallback<List<Cashout>> callback)
            throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call =
                cashoutGetValidateBeforeCall(serviceid, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<Cashout>>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for collectstdPost
     * @param body
     *            Collection Request (optional)
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call collectstdPostCall(CollectionstdRequest body,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        return postCall(body, progressListener, progressRequestListener, "/collectstd");
    }

    private Call collectstdPostValidateBeforeCall(CollectionstdRequest body,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'xApiVersion' is set
        //not needed xApiVersion is always set
        /* if (this.xApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xApiVersion' when calling collectstd(Async)");
        }*/


        return collectstdPostCall(body, progressListener, progressRequestListener);
    }

    /**
     * Execute payment collection This endpoint executes a payment collection. Any collection will
     * reduce the agent balance by service amount plus the service fee. Each collection must include
     * a reference to corresponding quote and payment authorization token. Whether or not fields are
     * mandatory depends on the service configuration
     * @param body
     *            Collection Request (optional)
     * @return Collectionstd
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public Collectionstd collectstdPost(CollectionstdRequest body) throws ApiException {
        ApiResponse<Collectionstd> resp = collectstdPostWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Execute payment collection This endpoint executes a payment collection. Any collection will
     * reduce the agent balance by service amount plus the service fee. Each collection must include
     * a reference to corresponding quote and payment authorization token. Whether or not fields are
     * mandatory depends on the service configuration
     * @param body
     *            Collection Request (optional)
     * @return ApiResponse&lt;Collectionstd&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<Collectionstd> collectstdPostWithHttpInfo(CollectionstdRequest body) throws ApiException {
        Call call = collectstdPostValidateBeforeCall(body, null, null);
        Type localVarReturnType = new TypeToken<Collectionstd>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Execute payment collection (asynchronously) This endpoint executes a payment collection. Any
     * collection will reduce the agent balance by service amount plus the service fee. Each
     * collection must include a reference to corresponding quote and payment authorization token.
     * Whether or not fields are mandatory depends on the service configuration
     * @param body
     *            Collection Request (optional)
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call collectstdPostAsync(CollectionstdRequest body,
            final ApiCallback<Collectionstd> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call =
                collectstdPostValidateBeforeCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Collectionstd>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for productGet
     * @param serviceid
     *            Filter products to only the selected service (optional)
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call productGetCall(Integer serviceid,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (serviceid != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("serviceid", serviceid));

        return getCall(progressListener, progressRequestListener, "/product", localVarQueryParams);
    }

    private Call productGetValidateBeforeCall(Integer serviceid,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'xApiVersion' is set
        //not needed xApiVersion is always set
        /* if (this.xApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xApiVersion' when calling productGet(Async)");
        }*/


        return productGetCall(serviceid, progressListener, progressRequestListener);
    }

    /**
     * Retrieve list of available products This service provides a list of all available products
     * for all services.
     * @param serviceid
     *            Filter products to only the selected service (optional)
     * @return List&lt;Product&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public List<Product> productGet(Integer serviceid) throws ApiException {
        ApiResponse<List<Product>> resp = productGetWithHttpInfo(serviceid);
        return resp.getData();
    }

    /**
     * Retrieve list of available products This service provides a list of all available products
     * for all services.
     * @param serviceid
     *            Filter products to only the selected service (optional)
     * @return ApiResponse&lt;List&lt;Product&gt;&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<List<Product>> productGetWithHttpInfo(Integer serviceid) throws ApiException {
        Call call = productGetValidateBeforeCall(serviceid, null, null);
        Type localVarReturnType = new TypeToken<List<Product>>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Retrieve list of available products (asynchronously) This service provides a list of all
     * available products for all services.
     * @param serviceid
     *            Filter products to only the selected service (optional)
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call productGetAsync(Integer serviceid, final ApiCallback<List<Product>> callback)
            throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call =
                productGetValidateBeforeCall(serviceid, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<Product>>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for quotestdPost
     * @param body
     *            Quote Request (optional)
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call quotestdPostCall(QuoteRequest body,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        return postCall(body, progressListener, progressRequestListener, "/quotestd");
    }

    private Call quotestdPostValidateBeforeCall(QuoteRequest body,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'xApiVersion' is set
        //not needed xApiVersion is always set
        /* if (this.xApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xApiVersion' when calling quotestdPost(Async)");
        }*/


        return quotestdPostCall(body, progressListener, progressRequestListener);
    }

    /**
     * Request quote with price details about the payment Calling this web-service requests a quote
     * from the system for the payment collection of the selected payment item and the specified
     * payment amount in the system. The amount is to be chosen based on the services amountType, so
     * can either be fixed or a custom entered value. The third parameter specifies the payment
     * method that the customer has chosen in order to pay for the collection, as there may be
     * additional charges depending on the selected method. A quote will only remain available for
     * short time (a few minutes) and will expire. A quote will return the actual costs involved in
     * collecting the payment. A quote always needs to be requested before making a
     * collection.\&quot;
     * @param body
     *            Quote Request (optional)
     * @return Quotestd
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public Quotestd quotestdPost(QuoteRequest body) throws ApiException {
        ApiResponse<Quotestd> resp = quotestdPostWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Request quote with price details about the payment Calling this web-service requests a quote
     * from the system for the payment collection of the selected payment item and the specified
     * payment amount in the system. The amount is to be chosen based on the services amountType, so
     * can either be fixed or a custom entered value. The third parameter specifies the payment
     * method that the customer has chosen in order to pay for the collection, as there may be
     * additional charges depending on the selected method. A quote will only remain available for
     * short time (a few minutes) and will expire. A quote will return the actual costs involved in
     * collecting the payment. A quote always needs to be requested before making a
     * collection.\&quot;
     * @param body
     *            Quote Request (optional)
     * @return ApiResponse&lt;Quotestd&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<Quotestd> quotestdPostWithHttpInfo(QuoteRequest body) throws ApiException {
        Call call = quotestdPostValidateBeforeCall(body, null, null);
        Type localVarReturnType = new TypeToken<Quotestd>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Request quote with price details about the payment (asynchronously) Calling this web-service
     * requests a quote from the system for the payment collection of the selected payment item and
     * the specified payment amount in the system. The amount is to be chosen based on the services
     * amountType, so can either be fixed or a custom entered value. The third parameter specifies
     * the payment method that the customer has chosen in order to pay for the collection, as there
     * may be additional charges depending on the selected method. A quote will only remain
     * available for short time (a few minutes) and will expire. A quote will return the actual
     * costs involved in collecting the payment. A quote always needs to be requested before making
     * a collection.\&quot;
     * @param body
     *            Quote Request (optional)
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call quotestdPostAsync(QuoteRequest body, final ApiCallback<Quotestd> callback)
            throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = quotestdPostValidateBeforeCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Quotestd>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for subscriptionGet
     * @param merchant
     *            Unique merchant code (required)
     * @param serviceid
     *            Unique service Identifier (required)
     * @param serviceNumber
     *            service number with merchant (e.g. policy number with an insurance company or tax
     *            number for a governmental institution) (required)
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call subscriptionGetCall(String merchant, String serviceid, String serviceNumber,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (merchant != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("merchant", merchant));
        if (serviceid != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("serviceid", serviceid));
        if (serviceNumber != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("serviceNumber", serviceNumber));

        return getCall(progressListener, progressRequestListener, "/subscription", localVarQueryParams);
    }

    private Call subscriptionGetValidateBeforeCall(String merchant, String serviceid,
            String serviceNumber, final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'xApiVersion' is set
        //not needed xApiVersion is always set
        /* if (this.xApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xApiVersion' when calling subscriptionGet(Async)");
        }*/

        // verify the required parameter 'merchant' is set
        if (merchant == null) {
            throw new ApiException("Missing the required parameter 'merchant' when calling subscriptionGet(Async)");
        }

        // verify the required parameter 'serviceid' is set
        if (serviceid == null) {
            throw new ApiException("Missing the required parameter 'serviceid' when calling subscriptionGet(Async)");
        }

        // verify the required parameter 'serviceNumber' is set
        if (serviceNumber == null) {
            throw new ApiException(
                    "Missing the required parameter 'serviceNumber' when calling subscriptionGet(Async)");
        }

        return subscriptionGetCall(merchant, serviceid, serviceNumber, progressListener, progressRequestListener);

    }

    /**
     * Get subscription payment handler A request to this endpoint looks up a subscription record
     * for a service by service number and retrieves its details if available. When calling the
     * endpoint the result set will contain a list of all available subscriptions registered under
     * the provided service number. Each subscription has its own Payment Item Identifier.
     * @param merchant
     *            Unique merchant code (required)
     * @param serviceid
     *            Unique service Identifier (required)
     * @param serviceNumber
     *            service number with merchant (e.g. policy number with an insurance company or tax
     *            number for a governmental institution) (required)
     * @return List&lt;Subscription&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public List<Subscription> subscriptionGet(String merchant, String serviceid, String serviceNumber)
            throws ApiException {
        ApiResponse<List<Subscription>> resp = subscriptionGetWithHttpInfo(merchant, serviceid, serviceNumber);
        return resp.getData();
    }

    /**
     * Get subscription payment handler A request to this endpoint looks up a subscription record
     * for a service by service number and retrieves its details if available. When calling the
     * endpoint the result set will contain a list of all available subscriptions registered under
     * the provided service number. Each subscription has its own Payment Item Identifier.
     * @param merchant
     *            Unique merchant code (required)
     * @param serviceid
     *            Unique service Identifier (required)
     * @param serviceNumber
     *            service number with merchant (e.g. policy number with an insurance company or tax
     *            number for a governmental institution) (required)
     * @return ApiResponse&lt;List&lt;Subscription&gt;&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<List<Subscription>> subscriptionGetWithHttpInfo(String merchant, String serviceid,
            String serviceNumber) throws ApiException {
        Call call =
                subscriptionGetValidateBeforeCall(merchant, serviceid, serviceNumber, null, null);
        Type localVarReturnType = new TypeToken<List<Subscription>>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get subscription payment handler (asynchronously) A request to this endpoint looks up a
     * subscription record for a service by service number and retrieves its details if available.
     * When calling the endpoint the result set will contain a list of all available subscriptions
     * registered under the provided service number. Each subscription has its own Payment Item
     * Identifier.
     * @param merchant
     *            Unique merchant code (required)
     * @param serviceid
     *            Unique service Identifier (required)
     * @param serviceNumber
     *            service number with merchant (e.g. policy number with an insurance company or tax
     *            number for a governmental institution) (required)
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call subscriptionGetAsync(String merchant, String serviceid, String serviceNumber,
            final ApiCallback<List<Subscription>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = subscriptionGetValidateBeforeCall(merchant, serviceid, serviceNumber,
                progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<Subscription>>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for topupGet
     * @param serviceid
     *            Filter topups to only the selected service (optional)
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call topupGetCall(Integer serviceid,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (serviceid != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("serviceid", serviceid));

        return getCall(progressListener, progressRequestListener, "/topup", localVarQueryParams);
    }

    private Call topupGetValidateBeforeCall(Integer serviceid,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'xApiVersion' is set
        //not needed xApiVersion is always set
        /* if (this.xApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xApiVersion' when calling topupGet(Async)");
        }*/


        return topupGetCall(serviceid, progressListener, progressRequestListener);
    }

    /**
     * Retrieve available topup packages This service provides a list of all available topup
     * packages. DEPRECTATED: Some providers will return a digital code for manual redeeming. This
     * code will be provided in the response object of a successful collection. This functionality
     * has been moved into the /voucher endpoint and will be removed in the next version of this API
     * @param serviceid
     *            Filter topups to only the selected service (optional)
     * @return List&lt;Topup&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public List<Topup> topupGet(Integer serviceid) throws ApiException {
        ApiResponse<List<Topup>> resp = topupGetWithHttpInfo(serviceid);
        return resp.getData();
    }

    /**
     * Retrieve available topup packages This service provides a list of all available topup
     * packages. DEPRECTATED: Some providers will return a digital code for manual redeeming. This
     * code will be provided in the response object of a successful collection. This functionality
     * has been moved into the /voucher endpoint and will be removed in the next version of this API
     * @param serviceid
     *            Filter topups to only the selected service (optional)
     * @return ApiResponse&lt;List&lt;Topup&gt;&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<List<Topup>> topupGetWithHttpInfo(Integer serviceid) throws ApiException {
        Call call = topupGetValidateBeforeCall(serviceid, null, null);
        Type localVarReturnType = new TypeToken<List<Topup>>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Retrieve available topup packages (asynchronously) This service provides a list of all
     * available topup packages. DEPRECTATED: Some providers will return a digital code for manual
     * redeeming. This code will be provided in the response object of a successful collection. This
     * functionality has been moved into the /voucher endpoint and will be removed in the next
     * version of this API
     * @param serviceid
     *            Filter topups to only the selected service (optional)
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call topupGetAsync(Integer serviceid, final ApiCallback<List<Topup>> callback)
            throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call =
                topupGetValidateBeforeCall(serviceid, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<Topup>>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for verifyGet
     * @param merchant
     *            Unique merchant code (required)
     * @param serviceid
     *            Unique service Identifier (required)
     * @param serviceNumber
     *            Service number with merchant (e.g. meter number in bills from a utility provider)
     *            for which to perform the bill payment (required)
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call verifyServiceNumberGetCall(String merchant, Integer serviceid, String serviceNumber,
                                           final ProgressResponseBody.ProgressListener progressListener,
                                           final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (merchant != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("merchant", merchant));
        if (serviceid != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("serviceid", serviceid));
        if (serviceNumber != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("serviceNumber", serviceNumber));

        return getCall(progressListener, progressRequestListener, "/verify", localVarQueryParams);
    }

    private Call verifyServiceNumberGetValidateBeforeCall(String merchant, Integer serviceid,
                                                          String serviceNumber, final ProgressResponseBody.ProgressListener progressListener,
                                                          final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'xApiVersion' is set
        //not needed xApiVersion is always set
        /* if (this.xApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xApiVersion' when calling verifyGet(Async)");
        }*/


        // verify the required parameter 'merchant' is set
        if (merchant == null) {
            throw new ApiException("Missing the required parameter 'merchant' when calling verifyGet(Async)");
        }

        // verify the required parameter 'serviceid' is set
        if (serviceid == null) {
            throw new ApiException("Missing the required parameter 'serviceid' when calling verifyGet(Async)");
        }

        // verify the required parameter 'serviceNumber' is set
        if (serviceNumber == null) {
            throw new ApiException("Missing the required parameter 'serviceNumber' when calling verifyGet(Async)");
        }

        return verifyServiceNumberGetCall(merchant, serviceid, serviceNumber, progressListener, progressRequestListener);
    }

    /**
     * Verify service number For services that support verification (indicated by the
     * \&quot;isVerifiable\&quot; flag) the service number can be provided to this endpoint. The
     * system will verify wether or not the service number is valid with the selected service.
     * @param merchant
     *            Unique merchant code (required)
     * @param serviceid
     *            Unique service Identifier (required)
     * @param serviceNumber
     *            Service number with merchant (e.g. meter number in bills from a utility provider)
     *            for which to perform the bill payment (required)
     * @return Boolean
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public Boolean  verifyServiceNumberGet(String merchant, Integer serviceid, String serviceNumber) throws ApiException {
        ApiResponse<Boolean> resp = verifyServiceNumberGetWithHttpInfo(merchant, serviceid, serviceNumber);
        return resp.getData();
    }

    /**
     * Verify service number For services that support verification (indicated by the
     * \&quot;isVerifiable\&quot; flag) the service number can be provided to this endpoint. The
     * system will verify wether or not the service number is valid with the selected service.
     * @param merchant
     *            Unique merchant code (required)
     * @param serviceid
     *            Unique service Identifier (required)
     * @param serviceNumber
     *            Service number with merchant (e.g. meter number in bills from a utility provider)
     *            for which to perform the bill payment (required)
     * @return ApiResponse&lt;Boolean&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<Boolean> verifyServiceNumberGetWithHttpInfo(String merchant, Integer serviceid, String serviceNumber)
            throws ApiException {
        Call call = verifyServiceNumberGetValidateBeforeCall(merchant, serviceid, serviceNumber, null, null);
        Type localVarReturnType = new TypeToken<Boolean>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Verify service number (asynchronously) For services that support verification (indicated by
     * the \&quot;isVerifiable\&quot; flag) the service number can be provided to this endpoint. The
     * system will verify wether or not the service number is valid with the selected service.
     * @param merchant
     *            Unique merchant code (required)
     * @param serviceid
     *            Unique service Identifier (required)
     * @param serviceNumber
     *            Service number with merchant (e.g. meter number in bills from a utility provider)
     *            for which to perform the bill payment (required)
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call verifyGetAsync(String merchant, Integer serviceid, String serviceNumber,
            final ApiCallback<Boolean> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = verifyServiceNumberGetValidateBeforeCall(merchant, serviceid, serviceNumber,
                progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Boolean>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for voucherGet
     * @param serviceid
     *            Filter products to only the selected service (optional)
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call voucherGetCall(Integer serviceid,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (serviceid != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("serviceid", serviceid));

        return getCall(progressListener, progressRequestListener, "/voucher", localVarQueryParams);
    }

    private Call voucherGetValidateBeforeCall(Integer serviceid,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'xApiVersion' is set
        //not needed xApiVersion is always set
        /* if (this.xApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xApiVersion' when calling voucherGet(Async)");
        }*/


        return voucherGetCall(serviceid, progressListener, progressRequestListener);
    }

    /**
     * Retrieve list of available vouchers to purchase This service provides a list of all available
     * vouchers for all services. A purchase of a voucher will return a digital code for manual
     * redeeming. This code will be provided in the response object of a successful collection.
     * @param serviceid
     *            Filter products to only the selected service (optional)
     * @return List&lt;Product&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public List<Topup> voucherGet(Integer serviceid) throws ApiException {
        ApiResponse<List<Topup>> resp = voucherGetWithHttpInfo(serviceid);
        return resp.getData();
    }

    /**
     * Retrieve list of available vouchers to purchase This service provides a list of all available
     * vouchers for all services. A purchase of a voucher will return a digital code for manual
     * redeeming. This code will be provided in the response object of a successful collection.
     * @param serviceid
     *            Filter products to only the selected service (optional)
     * @return ApiResponse&lt;List&lt;Product&gt;&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<List<Topup>> voucherGetWithHttpInfo(Integer serviceid) throws ApiException {
        Call call = voucherGetValidateBeforeCall(serviceid, null, null);
        Type localVarReturnType = new TypeToken<List<Topup>>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Retrieve list of available vouchers to purchase (asynchronously) This service provides a list
     * of all available vouchers for all services. A purchase of a voucher will return a digital
     * code for manual redeeming. This code will be provided in the response object of a successful
     * collection.
     * @param serviceid
     *            Filter products to only the selected service (optional)
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call voucherGetAsync(Integer serviceid, final ApiCallback<List<Product>> callback)
            throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call =
                voucherGetValidateBeforeCall(serviceid, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<Product>>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

}
