/*
 * Smobilpay S3P API STANDARD Smobilpay Third Party STANDARD API FOR PAYMENT COLLECTIONS OpenAPI
 * spec version: 2.2.0 NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git Do not edit the class manually.
 */

package org.maviance.s3pjavaclient.api;

import com.google.gson.reflect.TypeToken;
import com.squareup.okhttp.Call;
import org.maviance.s3pjavaclient.*;
import org.maviance.s3pjavaclient.model.Account;
import org.maviance.s3pjavaclient.model.Merchant;
import org.maviance.s3pjavaclient.model.Service;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;

public class MasterdataApi extends BaseApi {

    public MasterdataApi() {
        super();
    }

    public MasterdataApi(ApiClient apiClient) {
        super(apiClient);
    }

    /**
     * Build call for accountGet
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call accountGetCall(final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        return getCall(progressListener, progressRequestListener, "/account", new ArrayList<Pair>());
    }

    private Call accountGetValidateBeforeCall(
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        return accountGetCall(progressListener, progressRequestListener);

    }

    /**
     * Retrieve account information and remaining account balance This endpoint returns the user’s
     * account information – most notably the current balance of the user. Calling this service
     * before and after **each** collection in order to retrieve the current limits and/or balance
     * is **highly discouraged**. The recommended approach is as follows: 1. Only a successful
     * payment collection transaction will affect the account balance. The corresponding endpoint
     * will also return the current account balance after the collection in its result payload. 2.
     * For unsuccessful payment transactions, the account balance will not be affected. The error
     * message returns a verbose message as to why the transaction failed. There is no need to
     * recheck the account after each error.
     * @return Account
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public Account accountGet() throws ApiException {
        ApiResponse<Account> resp = accountGetWithHttpInfo();
        return resp.getData();
    }

    /**
     * Retrieve account information and remaining account balance This endpoint returns the user’s
     * account information – most notably the current balance of the user. Calling this service
     * before and after **each** collection in order to retrieve the current limits and/or balance
     * is **highly discouraged**. The recommended approach is as follows: 1. Only a successful
     * payment collection transaction will affect the account balance. The corresponding endpoint
     * will also return the current account balance after the collection in its result payload. 2.
     * For unsuccessful payment transactions, the account balance will not be affected. The error
     * message returns a verbose message as to why the transaction failed. There is no need to
     * recheck the account after each error.
     * @return ApiResponse&lt;Account&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<Account> accountGetWithHttpInfo() throws ApiException {
        Call call = accountGetValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<Account>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Retrieve account information and remaining account balance (asynchronously) This endpoint
     * returns the user’s account information – most notably the current balance of the user.
     * Calling this service before and after **each** collection in order to retrieve the current
     * limits and/or balance is **highly discouraged**. The recommended approach is as follows: 1.
     * Only a successful payment collection transaction will affect the account balance. The
     * corresponding endpoint will also return the current account balance after the collection in
     * its result payload. 2. For unsuccessful payment transactions, the account balance will not be
     * affected. The error message returns a verbose message as to why the transaction failed. There
     * is no need to recheck the account after each error.
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call accountGetAsync(final ApiCallback<Account> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = accountGetValidateBeforeCall(progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Account>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for merchantGet
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call merchantGetCall(final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        return getCall(progressListener, progressRequestListener, "/merchant", new ArrayList<Pair>());
    }

    private Call merchantGetValidateBeforeCall(
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        //validation of required inout data is supposed to be checked here
        return merchantGetCall(progressListener, progressRequestListener);

    }

    /**
     * Retrieve list of merchants supported by the system. Provides merchants supported by the
     * system. Every service is assigned to a merchant.
     * @return List&lt;Merchant&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public List<Merchant> merchantGet() throws ApiException {
        ApiResponse<List<Merchant>> resp = merchantGetWithHttpInfo();
        return resp.getData();
    }

    /**
     * Retrieve list of merchants supported by the system. Provides merchants supported by the
     * system. Every service is assigned to a merchant.
     * @return ApiResponse&lt;List&lt;Merchant&gt;&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<List<Merchant>> merchantGetWithHttpInfo() throws ApiException {
        Call call = merchantGetValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<List<Merchant>>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Retrieve list of merchants supported by the system. (asynchronously) Provides merchants
     * supported by the system. Every service is assigned to a merchant.
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call merchantGetAsync(final ApiCallback<List<Merchant>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = merchantGetValidateBeforeCall(progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<Merchant>>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for serviceGet
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call serviceGetCall(final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        return getCall(progressListener, progressRequestListener, "/service", new ArrayList<Pair>());
    }

    private Call serviceGetValidateBeforeCall(
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        Call call = serviceGetCall(progressListener, progressRequestListener);
        return call;
    }

    /**
     * Retrieve list of services supported by the system. This service endpoint provides information
     * about the services supported by . Each service has its own set of required input parameters
     * which need to be provided during the collection request - starting with the prefix “isReq”.
     * It is recommended that the application UI is configured based on the response values provided
     * here. The service response will also specify the type of the service and thus detail how the
     * related payment items can be retrieved and collected.
     * @return List&lt;Service&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public List<Service> serviceGet() throws ApiException {
        ApiResponse<List<Service>> resp = serviceGetWithHttpInfo();
        return resp.getData();
    }

    /**
     * Retrieve list of services supported by the system. This service endpoint provides information
     * about the services supported by . Each service has its own set of required input parameters
     * which need to be provided during the collection request - starting with the prefix “isReq”.
     * It is recommended that the application UI is configured based on the response values provided
     * here. The service response will also specify the type of the service and thus detail how the
     * related payment items can be retrieved and collected.
     * @return ApiResponse&lt;List&lt;Service&gt;&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<List<Service>> serviceGetWithHttpInfo() throws ApiException {
        Call call = serviceGetValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<List<Service>>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Retrieve list of services supported by the system. (asynchronously) This service endpoint
     * provides information about the services supported by . Each service has its own set of
     * required input parameters which need to be provided during the collection request - starting
     * with the prefix “isReq”. It is recommended that the application UI is configured based on the
     * response values provided here. The service response will also specify the type of the service
     * and thus detail how the related payment items can be retrieved and collected.
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call serviceGetAsync(final ApiCallback<List<Service>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = serviceGetValidateBeforeCall(progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<Service>>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for serviceIdGet
     * @param id
     *            Unique service Identifier. (required)
     * @param progressListener
     *            Progress listener
     * @param progressRequestListener
     *            Progress request listener
     * @return Call to execute
     * @throws ApiException
     *             If fail to serialize the request body object
     */
    public Call serviceIdGetCall(Integer id,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // create path and map variables
        String localVarPath = "/service/{id}".replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        return getCall(progressListener, progressRequestListener, localVarPath, new ArrayList<Pair>());
    }

    private Call serviceIdGetValidateBeforeCall(Integer id,
            final ProgressResponseBody.ProgressListener progressListener,
            final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling serviceIdGet(Async)");
        }

        Call call = serviceIdGetCall(id, progressListener, progressRequestListener);
        return call;
    }

    /**
     * Retrieve single service This service endpoint provides information about the selected
     * service. Each service has its own set of required input parameters which need to be provided
     * during the collection request - starting with the prefix “isReq”. It is recommended that the
     * application UI is configured based on the response values provided here. The service response
     * will also specify the type of the service and thus detail how the related payment items can
     * be retrieved and collected.
     * @param id
     *            Unique service Identifier. (required)
     * @return Service
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public Service serviceIdGet(Integer id) throws ApiException {
        ApiResponse<Service> resp = serviceIdGetWithHttpInfo(id);
        return resp.getData();
    }

    /**
     * Retrieve single service This service endpoint provides information about the selected
     * service. Each service has its own set of required input parameters which need to be provided
     * during the collection request - starting with the prefix “isReq”. It is recommended that the
     * application UI is configured based on the response values provided here. The service response
     * will also specify the type of the service and thus detail how the related payment items can
     * be retrieved and collected.
     * @param id
     *            Unique service Identifier. (required)
     * @return ApiResponse&lt;Service&gt;
     * @throws ApiException
     *             If fail to call the API, e.g. server error or cannot deserialize the response
     *             body
     */
    public ApiResponse<Service> serviceIdGetWithHttpInfo(Integer id) throws ApiException {
        Call call = serviceIdGetValidateBeforeCall(id, null, null);
        Type localVarReturnType = new TypeToken<Service>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Retrieve single service (asynchronously) This service endpoint provides information about the
     * selected service. Each service has its own set of required input parameters which need to be
     * provided during the collection request - starting with the prefix “isReq”. It is recommended
     * that the application UI is configured based on the response values provided here. The service
     * response will also specify the type of the service and thus detail how the related payment
     * items can be retrieved and collected.
     * @param id
     *            Unique service Identifier. (required)
     * @param callback
     *            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException
     *             If fail to process the API call, e.g. serializing the request body object
     */
    public Call serviceIdGetAsync(Integer id, final ApiCallback<Service> callback)
            throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = serviceIdGetValidateBeforeCall(id, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Service>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

}
